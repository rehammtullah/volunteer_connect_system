// flush.js
// 2013, Rumkin, https://bitbucket.org/rumkin/Flush.js.git
//
// doT.js is an open source component of http://bebedo.com
// Licensed under the MIT license.

(function (){
	"use strict";

	var Compiler = function() {};
	
	Compiler.settings = Compiler.prototype.settings = {
		variable : "data",
		trim     : true,
		debug    : false,
		// Regular expressions
		expression : /^\{% (.*(?!%\})) %\}/,
		output     : /^\{\{ (.*?(?!\}\})) \}\}/
	};

	Compiler.prototype.compile = function(string, options) {
			string = string || ''
			var result = ''
				, max   = 10000
				, regex = {
					expr : this.settings.expression,
					outp : this.settings.output
				}
				, prefix = ''
				, match, re

			if (this.settings.trim) {
				string = string.replace(/^\s+|\s+$/g,'')
			}

			var sign = '='

			while (max--) {
				if (match = regex.expr.exec(string)) {
					prefix     += string.substr(0, match.index)
					
					result += "out " + sign + " '" + this.escapeString(prefix) + "';"
					result += this.parse(match[1],['exprStart', 'exprEnd', 'exprElse', 'exprForeach'])

					string = string.substr(match.index + match[0].length)
					prefix = ''
					sign = "+="
					continue
				}

				if (match = regex.outp.exec(string)) {
					prefix     += string.substr(0, match.index)
					
					result += "out " + sign + " '" + this.escapeString(prefix) + "'"
					result += " + (" + match[1] + ");"

					string = string.substr(match.index + match[0].length)
					prefix = ''
					sign = "+="
					continue
				}

				prefix += string.substr(0, 1)
				string = string.substr(1)
				if ( ! string.length) break
			}

			if (prefix.length) result += "out += '" + this.escapeString(prefix) + "'; "

			result = "var out=''; " + result.replace(/^s+|\s+$/g, '') + " return out"
			if (this.settings.debug) {
				// Number lines
				var i = 0, line
				result = result.replace(/^|\r\n/g, function(match){
					line = '// line: ' + (++i)
					if (match.length)
						return '\r\n' + line + match
					else
						return line + '\r\n'
				})
			}

			try {
				var func = new Function(this.settings.variable, result)
			} catch (e) {
				throw new Error("Couldn't comiple template: " + result)
			}

			return func;
		};

	Compiler.prototype.escapeString = function(string) {
		var lineEnd = "\\r\\n'"
		if (this.settings.trim) {
			string = string.replace(/^\s+|\s+$/g, ' ')
			lineEnd += "+ '"
		} else {
			lineEnd += "\r\n+ '"
		}

		string = string.replace(/('|\\)/g, '\\$1').replace(/(\r\n\|\r|\n)/g,lineEnd)

		return string
	};

	Compiler.prototype.parse = function(string, parsers) {
		var parser, result
		for (var i = -1, l = parsers.length; l > (i +=1);) {
			parser = this.parsers[parsers[i]]
			result = parser.regex.exec(string)
			//console.log(result)
			if (result) return parser.out(result, string)

			//if (result !== false) return result
		}
		return string
	};

	Compiler.prototype.parsers = {
			// if, for, while ...
			exprStart : {
				regex : /^(if|for)\s*\(.*\)(\s*:)?$/,
				out : function(match, string){
					return string.replace(/\s*:$/, '') + " {"
				}
			},
			// else
			exprElse : {
				regex : /^else(\W|(\s*:)?$)/,
				out   : function(match, string) {
					return "} " + string.replace(/\s*:$/, '') + " {"
				}
			},
			// foreach
			exprForeach : {
				regex : /^foreach\s*\((.+)\s+as\s+(\w+)\)(\s*:)?$/,
				out   : function(match) {
					var vList = match[1]
					  , vName = match[2]
					return "if (" + vList + ") { for (var " + vName + "_i in " + vList + ") { var " + vName + " = " + vList + "[" + vName + "_i];"
				}
			},
			// expression end
			exprEnd : {
				regex : /^end(for|if|foreach)$/,
				out   : function(match, string) {
					if (match[1] === "foreach") {
						return "}}"
					} else {
						return "}"
					}
				}
			}
		};

	var Flush = {};
	Flush.Compiler = Compiler;
	Flush.create = function(options) {
		return new Compiler(options);
	};
	Flush.compile = function(template, options) {
		return (new Compiler()).compile(template, options);
	};
	// Bindings
	if (typeof window !== 'undefined') {
		window.Flush = Flush;
	}
	if (typeof define === 'function') {
		define(function(){ return Flush; });
	}
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = Compiler;
		module.exports.create  = Flush.create;
		module.exports.compile = Flush.compile;
	}
})();